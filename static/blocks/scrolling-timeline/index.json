{"html":"<div repeat-host=\"repeat-host\" class=\"timeline\"><div repeat-item=\"repeat-item\" class=\"item\"><h4>1998</h4><p>Year of Inspiration</p></div><div repeat-item=\"repeat-item\" class=\"item\"><h4>2003</h4><p>Renaissance</p></div><div repeat-item=\"repeat-item\" class=\"item\"><h4>2007</h4><p>Collaborative</p></div></div><div class=\"container\"><h2>Parallex Scrolling</h2><p>Parallax scrolling is a technique in computer graphics where background images move by the camera slower than foreground images, creating an illusion of depth in a 2D scene and adding to the immersion.</p><p>The technique grew out of the multiplane camera technique used in traditional animation since the 1930s. Parallax scrolling was popularized in 2D computer graphics and video games by the arcade games Moon Patrol and Jungle Hunt, both released in 1982.</p><p>Some parallax scrolling had earlier been used by the 1981 arcade game Jump Bug.[6]</p></div>","css":".block-scrolling-timeline {\n  height: 100vh;\n  max-height: 400px;\n}\n.block-scrolling-timeline > .inner {\n  height: 100%;\n}\n.block-scrolling-timeline .timeline {\n  padding: 20px;\n  position: absolute;\n  left: auto;\n  z-index: 1;\n  display: flex;\n  height: 100%;\n  background: rgba(255,255,255,0.9);\n  transition: all 0.5s ease-in-out;\n  flex-direction: column;\n  flex-wrap: nowrap;\n}\n.block-scrolling-timeline .timeline .item {\n  flex: 1 1 auto;\n  border-left: 1px solid #999;\n  padding: 0 10px 10px;\n  position: relative;\n  line-height: 10px;\n  transition: all 0.5s ease-in-out;\n}\n.block-scrolling-timeline .timeline .item > *:first-child {\n  margin-top: -10px;\n}\n.block-scrolling-timeline .timeline .item:before {\n  content: \" \";\n  display: block;\n  width: 10px;\n  height: 10px;\n  border-radius: 10px;\n  background: #777;\n  position: absolute;\n  left: -5px;\n  top: 0px;\n  border: 1px solid transparent;\n  transition: all 0.5s ease-in-out;\n}\n.block-scrolling-timeline .timeline .item.active {\n  color: #f00;\n}\n.block-scrolling-timeline .timeline .item.active:before {\n  border-color: #f00;\n  background: #fff;\n}\n.block-scrolling-timeline .timeline .item:last-child {\n  border-left: none;\n}\n.block-scrolling-timeline .timeline.sticky {\n  position: fixed;\n  top: 0;\n  left: auto;\n  padding-top: 60px;\n  opacity: 1;\n}\n.block-scrolling-timeline .timeline.no-transition {\n  transition: none;\n}\n","js":"// Generated by LiveScript 1.3.0\nmodule.exports = {\n  init: function(){\n    var this$ = this;\n    this.page.addEventListener('block.change', function(){\n      var nbox, timeline, tbox, cnode, i$, ref$, len$, item, results$ = [];\n      nbox = this$.block.getBoundingClientRect();\n      timeline = this$.block.querySelector('.timeline');\n      if (!timeline) {\n        return;\n      }\n      timeline.style.top = null;\n      timeline.style.height = nbox.height + \"px\";\n      timeline.classList.remove('sticky', 'no-transition');\n      tbox = timeline.getBoundingClientRect();\n      cnode = this$.block;\n      for (i$ = 0, len$ = (ref$ = btools.qsAll('.timeline .item', this$.block)).length; i$ < len$; ++i$) {\n        item = ref$[i$];\n        if (cnode) {\n          item.classList.remove('active');\n          if (cnode === this$.block) {\n            btools.qs('.inner .container', cnode).map(fn$);\n          } else {\n            btools.qs('.inner', cnode).map(fn1$);\n          }\n          results$.push(cnode = cnode.nextSibling);\n        }\n      }\n      return results$;\n      function fn$(it){\n        var offset;\n        offset = it.getBoundingClientRect().x - nbox.x;\n        return it.style.paddingLeft = (tbox.width + tbox.x - offset - nbox.x + 10) + \"px\";\n      }\n      function fn1$(it){\n        return it.style.marginLeft = (tbox.width + tbox.x - nbox.x + 10) + \"px\";\n      }\n    });\n    this.scrollListener = function(){\n      var timeline, row, items, tbox, rbox, scrolltop, nbox, lastNode, i$, len$, item, lbox, ref$, cnode, count, cbox, lastItem;\n      timeline = this$.block.querySelector('.timeline');\n      if (!(timeline && timeline.style)) {\n        return;\n      }\n      console.log(timeline);\n      row = this$.block.querySelector('.container');\n      items = timeline.querySelectorAll('.item');\n      tbox = timeline.getBoundingClientRect();\n      rbox = row.getBoundingClientRect();\n      if (!timeline) {\n        return;\n      }\n      scrolltop = document.scrollingElement.scrollTop;\n      nbox = this$.block.getBoundingClientRect();\n      lastNode = this$.block;\n      for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {\n        item = items[i$];\n        if (lastNode) {\n          lastNode = lastNode.nextSibling;\n        }\n      }\n      if (lastNode) {\n        lbox = lastNode.getBoundingClientRect();\n      }\n      ref$ = [this$.block, 0], cnode = ref$[0], count = ref$[1];\n      for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {\n        item = items[i$];\n        if (cnode) {\n          cbox = cnode.getBoundingClientRect();\n          item.classList.remove('active');\n          if (cbox && cbox.top >= window.innerHeight / 2 && lastItem) {\n            lastItem.classList.add('active');\n            lastItem = null;\n            break;\n          }\n          ref$ = [cnode.nextSibling, count + 1, item], cnode = ref$[0], count = ref$[1], lastItem = ref$[2];\n        }\n      }\n      if (lastItem) {\n        lastItem.classList.add('active');\n      }\n      if (rbox) {\n        if (rbox.top >= 0) {\n          timeline.classList.remove('sticky');\n          timeline.style.top = null;\n          timeline.style.height = nbox.height + \"px\";\n        } else if (rbox.top < 0) {\n          timeline.style.height = window.innerHeight + \"px\";\n          timeline.classList.add('sticky');\n          timeline.classList.remove('ldt-fade-out');\n        }\n      }\n      if (lbox && lbox.top <= window.innerHeight && cbox) {\n        timeline.classList.add('no-transition');\n        return timeline.style.top = (cbox.top + cbox.height - tbox.height) + \"px\";\n      } else {\n        return timeline.classList.remove('no-transition');\n      }\n    };\n    return window.addEventListener('scroll', this.scrollListener);\n  },\n  destroy: function(){\n    var cnode, i$, ref$, len$, item;\n    cnode = this.block.nextSibling;\n    for (i$ = 0, len$ = (ref$ = btools.qsAll('.timeline .item', this.block)).length; i$ < len$; ++i$) {\n      item = ref$[i$];\n      if (cnode) {\n        btools.qs('.inner', cnode).map(fn$);\n        cnode = cnode.nextSibling;\n      }\n    }\n    if (this.scrollListener) {\n      return window.removeEventListener('scroll', this.scrollListener);\n    }\n    function fn$(it){\n      return it.style.marginLeft = null;\n    }\n  }\n};"}