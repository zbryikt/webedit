// Generated by LiveScript 1.3.0
var collab, x$;
collab = {
  history: {
    backward: [],
    forward: [],
    redo: function(){
      var ret;
      for (;;) {
        ret = this.forward.splice(0, 1)[0];
        if (!ret) {
          return;
        }
        backward.push(ret);
        collab.doc.submitOp(ret.op, {
          forceApply: false
        });
        if (!ret.option.nobreak) {
          break;
        }
      }
    },
    undo: function(it){
      var group, ret;
      group = null;
      for (;;) {
        ret = this.backward.pop(it);
        if (!ret) {
          return;
        }
        this.forward.splice(0, 0, ret);
        collab.doc.submitOp(sharedb.types.map.json0.invert(ret.op), {
          source: {
            forceApply: true
          }
        });
        if (ret.option && ret.option.group && !group) {
          group = ret.option.group;
        }
        if (group && (!ret.option || ret.option.group !== group)) {
          break;
        }
        if (!(group || (ret.option && ret.option.nobreak))) {
          break;
        }
      }
    },
    log: function(op, option){
      option == null && (option = {});
      if (option.ignore) {
        return;
      }
      this.backward.push({
        op: op,
        option: option
      });
      if (this.forward.length) {
        return this.forward.splice(0);
      }
    }
  },
  action: {
    submitOp: function(op, option){
      option == null && (option = {});
      collab.history.log(op, option);
      return collab.doc.submitOp(op);
    },
    info: function(block){
      var ref$, node, doc, idx, type, eid;
      ref$ = [block, collab.doc], node = ref$[0], doc = ref$[1];
      if (!doc || !doc.data) {
        return [];
      }
      while (node && node.parentNode && !node.getAttribute('base-block')) {
        node = node.parentNode;
      }
      if (!node || !node.getAttribute || !node.parentNode || !node.getAttribute('base-block')) {
        return [];
      }
      idx = Array.from(node.parentNode.childNodes).indexOf(node);
      type = node.getAttribute('base-block');
      eid = node.getAttribute('eid');
      return [node, doc, idx, type, eid];
    },
    checkPath: function(value, path, initValue, option){
      initValue == null && (initValue = {});
      option == null && (option = {
        ignore: true
      });
      if (value) {
        return;
      }
      return this.submitOp([{
        p: path,
        oi: initValue
      }], option);
    },
    setPublic: function(isPublic){
      var attr, ref$;
      this.checkPath(collab.doc.data.attr, ["attr"]);
      attr = collab.doc.data.attr;
      if (!attr || attr.isPublic === isPublic) {
        return;
      }
      return this.submitOp([{
        p: ["attr"],
        od: attr,
        oi: (ref$ = import$({}, attr), ref$.isPublic = isPublic, ref$)
      }], {
        ignore: true
      });
    },
    setThumbnail: function(thumbnail){
      var doc, ref$;
      thumbnail == null && (thumbnail = null);
      if (!thumbnail) {
        return;
      }
      doc = collab.doc;
      this.checkPath(doc.data.attr, ["attr"]);
      if (!doc.data.attr.thumbnail) {
        return this.submitOp([{
          p: ["attr"],
          od: doc.data.attr,
          oi: (ref$ = import$({}, doc.data.attr), ref$.thumbnail = thumbnail, ref$)
        }], {
          ignore: true
        });
      } else {
        return this.submitOp([
          {
            p: ["attr", "thumbnail", 0],
            sd: doc.data.attr.thumbnail
          }, {
            p: ["attr", "thumbnail", 0],
            si: thumbnail
          }
        ], {
          ignore: true
        });
      }
    },
    setTitle: function(manualTitle){
      var this$ = this;
      if (this.setTitle.handler) {
        clearTimeout(this.setTitle.handler);
        this.setTitle.handler = null;
      }
      return this.setTitle.handler = setTimeout(function(){
        var doc, title, list, ref$;
        doc = collab.doc;
        title = manualTitle;
        if (!title) {
          list = Array.from(document.querySelector('#editor .inner').querySelectorAll('h1,h2,h3'));
          list.sort(function(a, b){
            if (a.nodeName === b.nodeName) {
              return 0;
            } else if (a.nodeName > b.nodeName) {
              return 1;
            } else {
              return -1;
            }
          });
          if (list[0]) {
            title = list[0].innerText;
          }
        }
        if (!title) {
          title = "untitled";
        }
        this$.checkPath(doc.data.attr, ["attr"]);
        if (doc.data.attr && doc.data.attr.title === title) {
          return;
        }
        if (title.length > 60) {
          title = title.substring(0, 57) + "...";
        }
        if (doc.data.attr && doc.data.attr.title) {
          return this$.submitOp([
            {
              p: ["attr", "title", 0],
              sd: doc.data.attr.title
            }, {
              p: ["attr", "title", 0],
              si: title
            }
          ], {
            ignore: true
          });
        } else {
          return this$.submitOp([{
            p: ["attr"],
            oi: (ref$ = import$({}, doc.data.attr || {}), ref$.title = title, ref$)
          }], {
            ignore: true
          });
        }
      }, 1000);
    },
    moveBlock: function(src, des){
      return this.submitOp([{
        p: ["child", src],
        lm: des
      }]);
    },
    deleteBlock: function(block){
      var ref$, node, doc, idx, type;
      ref$ = this.info(block), node = ref$[0], doc = ref$[1], idx = ref$[2], type = ref$[3];
      if (!node) {
        return;
      }
      return this.submitOp([{
        p: ["child", idx],
        ld: doc.data.child[idx]
      }]);
    },
    insertBlock: function(block){
      var ref$, node, doc, idx, type, eid;
      ref$ = this.info(block), node = ref$[0], doc = ref$[1], idx = ref$[2], type = ref$[3], eid = ref$[4];
      if (!node) {
        return;
      }
      this.submitOp([{
        p: ["child", idx],
        li: {
          content: this.blockContent(node),
          type: type,
          eid: eid
        }
      }]);
      this.setTitle();
      return this.editStyle(block);
    },
    blockContent: function(node){
      var inner;
      inner = Array.from(node.childNodes).filter(function(it){
        return /inner/.exec(it.getAttribute('class'));
      })[0];
      if (inner.querySelector("[auto-content]")) {
        inner = inner.cloneNode(true);
        Array.from(inner.querySelectorAll("[auto-content]")).map(function(me){
          return Array.from(me.childNodes).map(function(child){
            return me.removeChild(child);
          });
        });
      }
      return puredom.sanitize((inner || {}).innerHTML);
    },
    strDiff: function(path, oldstr, newstr, option){
      var ref$, doc, diffs, offset, ops, i$, len$, diff;
      path == null && (path = []);
      oldstr == null && (oldstr = '');
      newstr == null && (newstr = '');
      option == null && (option = {});
      ref$ = [collab.doc, fastDiff(oldstr, newstr), 0], doc = ref$[0], diffs = ref$[1], offset = ref$[2];
      ops = [];
      for (i$ = 0, len$ = diffs.length; i$ < len$; ++i$) {
        diff = diffs[i$];
        if (diff[0] === 0) {
          offset += diff[1].length;
        } else if (diff[0] === 1) {
          ops.push({
            p: path.concat([offset]),
            si: diff[1]
          });
          offset += diff[1].length;
        } else {
          ops.push({
            p: path.concat([offset]),
            sd: diff[1]
          });
        }
      }
      if (ops.length) {
        return this.submitOp(ops, option);
      }
    },
    editStyle: function(block, isRoot){
      var doc, style, ref$, obj, path, node, idx, type;
      isRoot == null && (isRoot = false);
      doc = collab.doc;
      style = block.getAttribute("style");
      if (isRoot) {
        style = style.replace(/width:\d+px;?/, '');
        ref$ = [doc.data, []], obj = ref$[0], path = ref$[1];
        if (obj.style && typeof obj.style === typeof {}) {
          this.submitOp([{
            p: path.concat(["style"]),
            od: obj.style
          }]);
        }
        if (!obj.style) {
          return this.submitOp([{
            p: path,
            od: obj,
            oi: (ref$ = import$({}, obj), ref$.style = style, ref$)
          }]);
        }
      } else {
        ref$ = this.info(block), node = ref$[0], doc = ref$[1], idx = ref$[2], type = ref$[3];
        if (!node || !doc.data.child[idx]) {
          return;
        }
        ref$ = [doc.data.child[idx], ["child", idx]], obj = ref$[0], path = ref$[1];
        if (!obj.style) {
          return this.submitOp([{
            p: path,
            ld: obj,
            li: (ref$ = import$({}, obj), ref$.style = style, ref$)
          }]);
        }
      }
      return this.strDiff(path.concat(['style']), obj.style, style);
    },
    editBlock: function(block, option){
      var ref$, node, doc, idx, type, content, diffs, offset;
      option == null && (option = {});
      ref$ = this.info(block), node = ref$[0], doc = ref$[1], idx = ref$[2], type = ref$[3];
      if (!node) {
        return;
      }
      content = {
        last: (doc.data.child[idx] || {}).content || '',
        now: this.blockContent(node)
      };
      diffs = fastDiff(content.last, content.now);
      if (!doc.data.child[idx]) {
        this.submitOp([{
          p: ["child", idx],
          li: {
            content: "",
            type: type,
            style: ""
          }
        }], option);
      }
      offset = 0;
      this.strDiff(['child', idx, 'content'], content.last, content.now, option);
      return this.setTitle();
    },
    cursor: function(user, cursor){
      var key;
      if (!user || !(user.key || user.guestkey) || !collab.doc || !collab.doc.data) {
        return;
      }
      key = user.key || user.guestkey;
      return collab.connection.send({
        cursor: {
          action: 'update',
          data: {
            cursor: cursor
          }
        }
      });
    },
    css: {
      prepare: function(){
        if (!collab.doc.data.css) {
          collab.action.submitOp([{
            p: ["css"],
            oi: {
              links: [],
              inline: "",
              theme: {}
            }
          }]);
        }
        return collab.doc.data.css;
      },
      editInline: function(value){
        var css;
        css = this.prepare();
        return collab.action.strDiff(["css", "inline"], css.inline || '', value);
      },
      addLink: function(link){
        var css;
        css = this.prepare();
        return collab.action.submitOp([{
          p: ["css", "links", css.links.length],
          li: link
        }]);
      },
      removeLink: function(link){
        var css, idx;
        css = this.prepare();
        idx = css.links.indexOf(link);
        if (!~idx) {
          return;
        }
        return collab.action.submitOp([{
          p: ["css", "links", idx],
          ld: link
        }]);
      },
      editTheme: function(obj){
        var css;
        css = this.prepare();
        return collab.action.submitOp([{
          p: ["css", "theme"],
          od: css.theme,
          oi: obj
        }]);
      }
    }
  },
  init: function(root, editor){
    var ref$, path, offline, doc, this$ = this;
    ref$ = [root, editor], this.root = ref$[0], this.editor = ref$[1];
    this.root.innerHTML = '';
    path = window.location.pathname;
    this.socket = new WebSocket((editor.server.scheme === 'http' ? 'ws' : 'wss') + "://" + editor.server.domain + "/ws");
    offline = function(){
      return editor.online.toggle(false);
    };
    if (this.socket.readyState >= 2) {
      return offline();
    }
    this.socket.addEventListener('close', function(evt){
      if (evt.code !== 3001) {
        return offline();
      }
    });
    this.socket.addEventListener('error', function(evt){
      if (this$.socket.readyState === 1) {
        return offline();
      }
    });
    this.connection = new sharedb.Connection(this.socket);
    this.connection.on('receive', function(it){
      var ref$, cursor;
      if (it.data && !it.data.cursor) {
        return;
      }
      ref$ = [it.data.cursor, null], cursor = ref$[0], it.data = ref$[1];
      return editor.collaborator.handle(cursor);
    });
    this.pageid = /^\/page\//.exec(path) ? path.replace(/^\/page\//, '').replace(/\/$/, '') : null;
    this.doc = doc = this.connection.get('doc', this.pageid);
    doc.on('load', function(){
      var i$, ref$, len$, idx, v;
      if (doc.data) {
        for (i$ = 0, len$ = (ref$ = doc.data.child).length; i$ < len$; ++i$) {
          idx = i$;
          v = ref$[i$];
          if (v) {
            editor.block.prepare(v.content, {
              name: v.type,
              idx: idx,
              redo: false,
              style: v.style || '',
              source: false,
              eid: v.eid
            });
          }
        }
        editor.block.init();
        editor.page.prepare(doc.data);
        editor.css.prepare(doc.data.css) || {};
      }
      editor.loading.toggle(false);
      return editor.collaborator.init();
    });
    return doc.fetch(function(e){
      if (e) {
        return editor.online.toggle(false, {
          code: 403
        });
      }
      return setTimeout(function(){
        var ret;
        doc.subscribe(function(ops, source){
          return this$.handle(ops, source);
        });
        doc.on('op', function(ops, source){
          return this$.handle(ops, source);
        });
        if (!doc.type) {
          return ret = doc.create({
            attr: {},
            style: '',
            child: [],
            collaborator: {}
          });
        }
      }, 500);
    });
  },
  handle: function(ops, source){
    var i$, len$, op, node, ref$, src, des, desnode, results$ = [];
    if (!ops || (source && !source.forceApply)) {
      return;
    }
    for (i$ = 0, len$ = ops.length; i$ < len$; ++i$) {
      op = ops[i$];
      if (op.si || op.sd) {
        if (op.p[2] === 'style') {
          node = this.root.childNodes[op.p[1]];
          results$.push(this.editor.block.style.update(node, this.doc.data.child[op.p[1]].style || ''));
        } else if (op.p[0] === 'style') {
          results$.push(this.root.style = this.doc.data.style || '');
        } else if (op.p[0] === 'css' && op.p[1] === 'inline') {
          results$.push(this.editor.css.inline.update(this.doc.data.css.inline));
        } else if (op.p[0] === 'attr') {} else if (op.p[0] === 'child' && op.p[2] === 'content' && op.p.length === 4) {
          node = this.root.childNodes[op.p[1]];
          results$.push(this.editor.block.prepareAsync(node, {
            name: node.getAttribute('base-block'),
            idx: op.p[1],
            redo: true,
            eid: this.doc.data.child[op.p[1]].eid,
            content: this.doc.data.child[op.p[1]].content,
            source: false
          }));
        }
      } else if (op.li || op.ld) {
        if (op.ld) {
          if (op.p[0] === 'child') {
            node = this.root.childNodes[op.p[1]];
            node.parentNode.removeChild(node);
            this.editor.block.indexing();
            node.deleted = true;
            this.editor.handles.hide(node);
          } else if (op.p[0] === 'css' && op.p[1] === 'links') {
            this.editor.css.links.remove(op.ld);
          }
        }
        if (op.li) {
          if (op.p[0] === 'child') {
            this.editor.block.prepare(op.li.content, {
              name: op.li.type,
              idx: op.p[1],
              redo: false,
              style: op.li.style,
              source: false,
              eid: op.li.eid
            });
            results$.push(this.editor.block.indexing());
          } else if (op.p[0] === 'css' && op.p[1] === 'links') {
            results$.push(this.editor.css.links.add(op.li));
          }
        }
      } else if (op.lm != null) {
        ref$ = [op.p[1], op.lm], src = ref$[0], des = ref$[1];
        if (src !== des) {
          node = this.root.childNodes[src];
          desnode = this.root.childNodes[des + (src < des ? 1 : 0)];
          this.root.removeChild(node);
          if (!desnode) {
            this.root.appendChild(node);
          } else {
            this.root.insertBefore(node, desnode);
          }
          results$.push(this.editor.block.indexing());
        }
      } else if (op.oi) {
        if (op.p[0] === 'attr') {
          results$.push(collab.editor.page.share.setPublic(this.doc.data.attr.isPublic));
        } else if (op.p[0] === 'css') {
          results$.push(collab.editor.css.theme.update(op.oi));
        }
      } else if (op.od) {}
    }
    return results$;
  }
};
x$ = angular.module('webedit');
x$.service('collaborate', ['$rootScope'].concat(function($rootScope){
  return collab;
}));
x$.controller('collabInfo', ['$scope', '$http'].concat(function($scope, $http){
  var panel;
  panel = document.querySelector('#collab-info');
  panel.style.left = (1024 + Math.round((window.innerWidth - 1024) / 2)) + "px";
  return panel.style.right = "auto";
}));
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}