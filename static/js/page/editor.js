// Generated by LiveScript 1.3.0
var x$;
x$ = angular.module('webedit');
x$.service('nodeProxy', ['$rootScope'].concat(function($rootScope){
  var ret;
  ret = function(node, sync){
    var originNode, queryId, retfunc;
    sync == null && (sync = true);
    originNode = node;
    queryId = "_node-proxy-" + Math.random().toString(16).substring(2);
    node.setAttribute(queryId, true);
    if (sync) {
      ret.editProxy.editBlock(node);
    }
    retfunc = function(){
      return document.querySelector("[" + queryId + "]") || (function(){
        throw new Error("node " + queryId + " not found");
      }());
    };
    retfunc.destroy = function(){
      var newnode;
      newnode = retfunc();
      newnode.removeAttribute(queryId);
      if (sync) {
        ret.editProxy.editBlock(newnode);
      }
      return newnode;
    };
    return retfunc;
  };
  ret.init = function(it){
    return ret.editProxy = it;
  };
  return ret;
}));
x$.service('blockLoader', ['$rootScope', '$http'].concat(function($scope, $http){
  var ret;
  return ret = {
    cache: {},
    get: function(name){
      var this$ = this;
      return new Promise(function(res, rej){
        var that;
        if (that = this$.cache[name]) {
          return res(that);
        }
        return $http({
          url: "/blocks/" + name + "/index.json"
        }).then(function(ret){
          var that, exports;
          this$.cache[name] = ret.data;
          if (that = this$.cache[name].js) {
            exports = eval("var module = {exports: {}};\n(function(module) { " + that + " })(module);\nmodule.exports;");
            this$.cache[name].exports = exports;
            if ((exports.custom || (exports.custom = {})).attrs) {
              puredom.useAttr(exports.custom.attrs);
            }
          }
          return res(this$.cache[name]);
        });
      });
    }
  };
}));
x$.service('webSettings', ['$rootScope'].concat(function($rootScope){
  var ret;
  ret = {
    unit: {},
    style: {},
    info: {},
    list: ['fontFamily', 'backgroundPositionX', 'backgroundPositionY', 'backgroundRepeat', 'backgroundAttachment', 'backgroundSize', 'fontWeight', 'boxShadow', 'animationName', 'backgroundImage', 'backgroundColor', 'color', 'fontSize', 'marginTop', 'marginBottom', 'marginLeft', 'marginRight', 'paddingTop', 'paddingBottom', 'paddingLeft', 'paddingRight', 'borderTopWidth', 'borderLeftWidth', 'borderRightWidth', 'borderBottomWidth', 'borderTopColor', 'borderLeftColor', 'borderRightColor', 'borderBottomColor'],
    option: {
      fontFamily: [
        {
          name: 'Default',
          value: 'default'
        }, {
          name: 'Arial',
          value: 'Arial'
        }, {
          name: 'Helvetica Neue',
          value: 'Helvetica Neue'
        }, {
          name: 'Tahoma',
          value: 'Tahoma'
        }, {
          name: 'Raleway',
          value: 'Raleway'
        }, {
          name: '微軟正黑體',
          value: "Microsoft JhengHei"
        }, {
          name: '黑體(繁)',
          value: "Heiti TC"
        }, {
          name: '黑體(簡)',
          value: "Heiti SC"
        }, {
          name: '蘋方體(繁)',
          value: "PingFangTC-Regular"
        }, {
          name: '細明體',
          value: "MingLiU"
        }, {
          name: '標楷體',
          value: 'DFKai-sb'
        }
      ],
      backgroundPositionX: ['default', 'left', 'center', 'right'],
      backgroundPositionY: ['default', 'top', 'center', 'bottom'],
      backgroundRepeat: ['default', 'repeat', 'repeat-x', 'repeat-y', 'no-repeat'],
      backgroundAttachment: ['default', 'scroll', 'fixed', 'local'],
      backgroundSize: ['default', 'cover', 'contain', 'auto'],
      fontWeight: ['default', '200', '300', '400', '500', '600', '700', '800', '900'],
      boxShadow: ['default', 'none', 'light', 'modest', 'heavy'],
      animationName: ['inherit', 'none', 'bounce', 'slide', 'fade']
    },
    setBlock: function(block){
      var this$ = this;
      this.style = {};
      (block.getAttribute('style') || '').split(';').map(function(it){
        var name, value;
        it = it.split(":").map(function(it){
          return it.trim();
        });
        if (!it[1] || !it[0]) {
          return;
        }
        name = it[0].split('-').map(function(d, i){
          if (i) {
            return d[0].toUpperCase() + d.substring(1);
          } else {
            return d;
          }
        }).join('');
        value = it[1];
        return this$.style[name] = value;
      });
      import$(this.info, {
        id: "#" + block.getAttribute('id')
      });
      return this.block = block;
    }
  };
  ['marginLeft', 'marginTop', 'marginRight', 'marginBottom', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'borderLeftWidth', 'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'fontSize'].map(function(it){
    return ret.unit[it] = "px";
  });
  ['animationDuration', 'animationDelay'].map(function(it){
    return ret.unit[it] = "s";
  });
  return ret;
}));
x$.controller('webSettings', ['$scope', '$timeout', 'webSettings', 'collaborate', 'editProxy'].concat(function($scope, $timeout, webSettings, collaborate, editProxy){
  $scope.settings = webSettings;
  $scope.reset = function(){
    return $scope.settings.style = {};
  };
  $scope.setBackgroundImage = function(){
    var shrink, dialog;
    shrink = "1024x1024";
    dialog = uploadcare.openDialog(null, null, {
      imageShrink: shrink,
      crop: 'free'
    });
    return dialog.done(function(it){
      var file, that;
      file = ((that = it.files)
        ? that()
        : [it])[0];
      $scope.settings.style.backgroundImage = "url(/assets/img/loader/msg.svg)";
      return file.done(function(info){
        return $scope.settings.style.backgroundImage = "url(" + info.cdnUrl + ")";
      });
    });
  };
  $scope.actionHandle = null;
  return $scope.$watch('settings.style', function(n, o){
    var i$, ref$, len$, k, v;
    if (!webSettings.block) {
      return;
    }
    for (i$ = 0, len$ = (ref$ = $scope.settings.list).length; i$ < len$; ++i$) {
      k = ref$[i$];
      v = $scope.settings.style[k];
      if (!v || v === 'default') {
        webSettings.block.style[k] = $scope.settings.style[k] = '';
      } else {
        webSettings.block.style[k] = v + (webSettings.unit[k] || '');
      }
    }
    if ($scope.actionHandle) {
      $timeout.cancel($scope.actionHandle);
      $scope.actionHandle = null;
    }
    return $scope.actionHandle = $timeout(function(){
      return editProxy.editStyle(webSettings.block, webSettings.block === document.querySelector('#editor > .inner'));
    }, 200);
  }, true);
}));
x$.service('editAux', ['$rootScope'].concat(function($rootScope){
  var aux;
  return aux = {
    cleanAttrs: function(root, attrs){
      var i$, len$, attr, to$, i, results$ = [];
      attrs == null && (attrs = []);
      if (!root.removeAttribute) {
        return;
      }
      for (i$ = 0, len$ = attrs.length; i$ < len$; ++i$) {
        attr = attrs[i$];
        root.removeAttribute(attr);
      }
      for (i$ = 0, to$ = root.childNodes.length; i$ < to$; ++i$) {
        i = i$;
        results$.push(this.cleanAttrs(root.childNodes[i], attrs));
      }
      return results$;
    },
    traceNonText: function(node){
      while (node && node.nodeType === 3) {
        node = node.parentNode;
      }
      return node && node.nodeType === 3 ? null : node;
    },
    traceBaseBlock: function(node){
      while (node && (node.nodeType === 3 || (node.getAttribute && !node.getAttribute("base-block")))) {
        node = node.parentNode;
      }
      return node && node.getAttribute && node.getAttribute("base-block") ? node : null;
    },
    eid: function(target){
      var count, eid;
      count = 0;
      while (count < 100) {
        eid = Math.random().toString(16).substring(2);
        if (!document.querySelector("[eid='" + eid + "']")) {
          break;
        }
        count++;
      }
      if (count < 100) {
        return target.setAttribute('eid', eid);
      }
    }
  };
}));
x$.service('editProxy', ['$rootScope', '$timeout', 'collaborate', 'editAux'].concat(function($rootScope, $timeout, collaborate, aux){
  var editProxy;
  editProxy = {
    change: function(blocks){
      var this$ = this;
      blocks == null && (blocks = []);
      blocks = blocks.filter(function(it){
        return it;
      });
      if (this.change.handle) {
        $timeout.cancel(this.change.handle);
      }
      return this.change.handle = $timeout(function(){
        this$.change.handle = null;
        pageObject.fire('block.change', {
          blocks: blocks
        });
        return blocks.map(function(block){
          var node;
          node = aux.traceBaseBlock(block);
          if (node && (node.obj || (node.obj = {})).change) {
            return node.obj.change([block], true);
          }
        });
      }, 100);
    },
    editStyle: function(block, isRoot){
      isRoot == null && (isRoot = false);
      this.change([block]);
      return collaborate.action.editStyle(block, isRoot);
    },
    editBlockAsync: function(block, option){
      var this$ = this;
      if (this.editBlockAsync.handle) {
        $timeout.cancel(this.editBlockAsync.handle);
      }
      return this.editBlockAsync.handle = $timeout(function(){
        this$.editBlockAsync.handle = null;
        this$.change([block]);
        return collaborate.action.editBlock(block, option);
      }, 10);
    },
    editBlock: function(block, option){
      this.change([block]);
      return collaborate.action.editBlock(block, option);
    },
    insertBlock: function(block){
      this.change([block]);
      return collaborate.action.insertBlock(block);
    },
    deleteBlock: function(block){
      var node;
      this.change([block]);
      node = aux.traceBaseBlock(block);
      if ((node.obj || (node.obj = {})).destroy) {
        node.obj.destroy();
      }
      return collaborate.action.deleteBlock(block);
    },
    moveBlock: function(src, des){
      this.change([src, des]);
      return collaborate.action.moveBlock(src, des);
    },
    setThumbnail: function(thumbnail){
      return collaborate.action.setThumbnail(thumbnail);
    }
  };
  return editProxy;
}));
x$.controller('editor', ['$scope', '$interval', '$timeout', 'ldBase', 'blockLoader', 'collaborate', 'global', 'webSettings', 'editProxy', 'nodeProxy', 'ldNotify', 'editAux'].concat(function($scope, $interval, $timeout, ldBase, blockLoader, collaborate, global, webSettings, editProxy, nodeProxy, ldNotify, aux){
  var medium, imageHandle, textHandle, nodeHandle, sortEditable, page, block, editor, ref$, x$, lastCursor, blocksPicker, blocksPreview;
  $scope.loading = true;
  nodeProxy.init(editProxy);
  medium = {
    list: [],
    pause: function(){
      return this.list.map(function(it){
        return it.destroy();
      });
    },
    resume: function(){
      return this.list.map(function(it){
        return it.setup();
      });
    },
    prepare: function(block){
      var me;
      me = new MediumEditor(block, {
        toolbar: {
          buttons: ['bold', 'italic', 'underline', 'indent'].map(function(it){
            return {
              name: it,
              contentDefault: "<i class='fa fa-" + it + "'></i>"
            };
          }).concat(['h1', 'h2', 'h3', 'h4'], [
            {
              name: 'orderedlist',
              contentDefault: "<i class='fa fa-list-ol'></i>"
            }, {
              name: 'unorderedlist',
              contentDefault: "<i class='fa fa-list-ul'></i>"
            }, {
              name: 'foreColor',
              contentDefault: "<i class='fa fa-adjust'></i>"
            }, {
              name: 'backColor',
              contentDefault: "<i class='fa fa-paint-brush'></i>"
            }, {
              name: 'borderColor',
              contentDefault: "<i class='fa fa-square-o'></i>"
            }, {
              name: 'align-left',
              contentDefault: '1'
            }, {
              name: 'align-center',
              contentDefault: '2'
            }, {
              name: 'align-right',
              contentDefault: '3'
            }, {
              name: 'font-size',
              contentDefault: "4"
            }, {
              name: 'font-family',
              contentDefault: "5"
            }, {
              name: 'anchor',
              contentDefault: "<i class='fa fa-link'></i>"
            }, {
              name: 'clear',
              contentDefault: "<i class='fa fa-eraser'></i>"
            }
          ])
        },
        extensions: {
          alignLeft: mediumEditorAlignExtention.left,
          alignCenter: mediumEditorAlignExtention.center,
          alignRight: mediumEditorAlignExtention.right,
          backColor: new mediumEditorStyleExtension.backColor(),
          foreColor: new mediumEditorStyleExtension.foreColor(),
          borderColor: new mediumEditorStyleExtension.borderColor(),
          fontSize: new mediumEditorFontsizeExtension(),
          fontFamily: new mediumEditorFontfamilyExtension(),
          clear: new mediumEditorClearExtension()
        },
        spellcheck: false,
        placeholder: {
          text: ''
        }
      });
      this.list.push(me);
      me.subscribe('editableInput', function(evt, elem){
        var sel, range, node, eid;
        sel = document.getSelection();
        if (sel.rangeCount) {
          range = sel.getRangeAt(0);
          node = aux.traceNonText(range.startContainer);
          if (node) {
            eid = node.getAttribute('eid');
            if (document.querySelectorAll("[eid='" + eid + "']").length > 1) {
              aux.eid(node);
            }
          }
        }
        return editProxy.editBlock(elem);
      });
      return me;
    }
  };
  imageHandle = {
    init: function(){
      return this.handle = document.querySelector('#editor-image-handle');
    },
    aspect: {
      lock: false,
      toggle: function(value, elem){
        this.lock = value != null
          ? value
          : !this.lock;
        if (elem.nodeName === 'IMG' || (elem.nodeName === 'DIV' && elem.getAttribute('image') && elem.childNodes.length === 0)) {
          elem = this.convert(elem);
        }
        if (this.lock) {
          return elem.setAttribute('preserve-aspect-ratio', true);
        } else {
          return elem.removeAttribute('preserve-aspect-ratio');
        }
      },
      convert: function(elem){
        var box, ratio, imgInner, img;
        box = elem.getBoundingClientRect();
        ratio = Math.round(100 * (box.width / box.height)) * 0.01;
        imgInner = document.createElement("div");
        imgInner.style.paddingBottom = "50%";
        imgInner.style.height = "0";
        img = document.createElement("div");
        img.appendChild(imgInner);
        img.setAttribute('editable', false);
        img.setAttribute('contenteditable', false);
        img.setAttribute('image', 'image');
        img.setAttribute('image-ratio', ratio);
        img.style.backgroundImage = elem.style.backgroundImage;
        img.style.backgroundColor = "";
        img.style.width = box.width + "px";
        img.style.backgroundSize = "100% 100%";
        imgInner.style.paddingBottom = 100 / ratio + "%";
        elem.parentNode.insertBefore(img, elem);
        elem.parentNode.removeChild(elem);
        imageHandle.resizable(img);
        editProxy.editBlock(img);
        return img;
      }
    },
    click: function(target){
      var retarget, box, size, shrink, dialog;
      if (target) {
        this.target = target;
      }
      if (!this.target) {
        return;
      }
      target = this.target;
      retarget = nodeProxy(target);
      box = this.target.getBoundingClientRect();
      size = Math.round((box.width > box.height
        ? box.width
        : box.height) * 2);
      if (size > 1024) {
        size = 1024;
      }
      shrink = size + "x" + size;
      /* dont upload local image
      ret = /url\("([^"]+)"\)/.exec(window.getComputedStyle(target).backgroundImage or "")
      file = if ret => ret.1 else null
      file = uploadcare.fileFrom 'url', file
      */
      dialog = uploadcare.openDialog(null, null, {
        multiple: !!target.getAttribute('repeat-item'),
        imageShrink: shrink,
        crop: 'free'
      });
      dialog.fail(function(){
        return retarget.destroy();
      });
      return dialog.done(function(ret){
        return Promise.resolve().then(function(){
          var files, that, nodes;
          files = (that = ret.files)
            ? that()
            : [ret];
          if (files.length === 1) {
            retarget().style.backgroundImage = "url(/assets/img/loader/msg.svg)";
            return files[0].done(function(info){
              retarget().style.backgroundImage = "url(" + info.cdnUrl + ")";
              editProxy.editBlock(retarget.destroy());
              return editProxy.setThumbnail(info.cdnUrl + "/-/preview/1200x630/");
            });
          } else {
            nodes = retarget().parentNode.querySelectorAll('[image]');
            Array.from(nodes).map(function(it){
              return it.style.backgroundImage = "url(/assets/img/loader/msg.svg)";
            });
            return Promise.all(files.map(function(it){
              return it.promise();
            })).then(function(images){
              var ref$, nodes, j, i$, to$, i;
              ref$ = [retarget().parentNode.querySelectorAll('[image]'), 0], nodes = ref$[0], j = ref$[1];
              for (i$ = 0, to$ = nodes.length; i$ < to$; ++i$) {
                i = i$;
                nodes[i].style.backgroundImage = "url(" + images[j].cdnUrl + ")";
                j = (j + 1) % images.length;
              }
              editProxy.editBlock(retarget.destroy());
              return editProxy.setThumbnail(images[0].cdnUrl + "/-/preview/1200x630/");
            });
          }
        })['catch'](function(e){
          return alert("the image node you're editing is removed by others.");
        });
      });
    },
    resizable: function(imgs){
      var this$ = this;
      imgs == null && (imgs = []);
      if (!Array.isArray(imgs)) {
        imgs = [imgs].filter(function(it){
          return it;
        });
      }
      return imgs.map(function(img){
        if (img.getAttribute('image') === 'bk' || img.resizabled || img.getAttribute('resizable') === 'false') {
          return;
        }
        img.resizabled = true;
        img.addEventListener('mousedown', function(e){
          var ref$, x, y, box;
          if (!img.getAttribute('image')) {
            return;
          }
          ref$ = [e.offsetX, e.offsetY], x = ref$[0], y = ref$[1];
          box = this.getBoundingClientRect();
          ref$ = [x / box.width, y / box.height], x = ref$[0], y = ref$[1];
          if (x < 0.1 || x > 0.9 || y < 0.1 || y > 0.9) {
            e.preventDefault();
            return e.stopPropagation();
          }
        });
        return interact(img).resizable({
          edges: {
            left: true,
            right: true,
            bottom: true,
            top: true
          }
        }).on('resizeend', function(e){
          return e.target._interactResize = true;
        }).on('resizemove', function(e){
          var target, w, h, ratio;
          target = e.target;
          w = target.getBoundingClientRect().width + e.deltaRect.width;
          h = target.getBoundingClientRect().height + e.deltaRect.height;
          ratio = +target.getAttribute('image-ratio');
          if (isNaN(ratio) || !ratio) {
            ratio = Math.round(100 * w / (h || 1)) * 0.01;
            target.setAttribute('image-ratio', ratio);
          }
          if (this$.aspect.lock) {
            if (e.deltaRect.width) {
              h = w / ratio;
            } else if (e.deltaRect.height) {
              w = h * ratio;
            }
          }
          target.style.width = w + "px";
          if (target.getAttribute('image')) {
            target.style.height = h + "px";
          }
          target.style.flex = "0 0 " + w + "px";
          target.style.transition = "none";
          if (img.handle) {
            $timeout.cancel(img.handle);
          }
          img.handle = $timeout(function(){
            target.style.flex = "1 1 auto";
            img.handle = null;
            return target.style.transition = ".5s all cubic-bezier(.3,.1,.3,.9)";
          }, 500);
          return editProxy.editBlockAsync(target, {
            group: 'resize'
          });
        });
      });
    }
  };
  imageHandle.init();
  textHandle = {
    elem: null,
    coord: {
      x: 0,
      y: 0
    },
    init: function(){
      var this$ = this;
      this.elem = document.querySelector('#editor-text-handle');
      this.elem.addEventListener('mouseover', function(e){
        if (!this$.timeout) {
          return;
        }
        $timeout.cancel(this$.timeout);
        return this$.timeout = null;
      });
      this.elem.addEventListener('keypress', function(e){
        if (e.keyCode === 13) {
          this$.save();
        }
        if (!this$.timeout) {
          return;
        }
        $timeout.cancel(this$.timeout);
        return this$.timeout = null;
      });
      return this.elem.addEventListener('click', function(e){
        if (e.target.classList.contains('medium-editor-toolbar-save')) {
          return this$.save();
        } else if (e.target.classList.contains('medium-editor-toolbar-close')) {
          return this$.toggle(null);
        }
      });
    },
    save: function(){
      var text, info, this$ = this;
      text = this.elem.querySelector('input').value;
      info = collaborate.action.info(this.target);
      return blockLoader.get(info[3]).then(function(ret){
        var node;
        node = aux.traceBaseBlock(this$.target);
        if ((node.obj || (node.obj = {})).transformText) {
          text = node.obj.transformText(text);
        }
        if (text) {
          this$.target.setAttribute(this$.target.getAttribute('edit-text'), text);
        }
        if ((node.obj || (node.obj = {})).text) {
          text = node.obj.text(text);
        }
        editProxy.editBlock(this$.target);
        return this$.toggle(null);
      });
    },
    toggle: function(options){
      var this$ = this;
      options == null && (options = {});
      if (this.timeout) {
        $timeout.cancel(this.timeout);
        this.timeout = null;
      }
      if (!options.delay) {
        return this._toggle(options);
      } else {
        return this.timeout = $timeout(function(){
          return this$._toggle(options);
        }, options.delay);
      }
    },
    _toggle: function(options){
      var node, inside, text, placeholder, animation, ref$, box, coord, x$;
      node = options.node, inside = options.inside, text = options.text, placeholder = options.placeholder;
      if (!this.elem) {
        this.init();
      }
      if (placeholder) {
        this.elem.querySelector('input').setAttribute('placeholder', placeholder);
      }
      animation = 'ldt-slide-bottom-in';
      if (node !== this.target) {
        this.elem.classList.remove(animation);
      }
      if (!node) {
        return this.elem.style.display = 'none';
      }
      ref$ = [node, node.getBoundingClientRect()], this.target = ref$[0], box = ref$[1];
      coord = {
        x: (box.x + box.width * 0.5 - 150) + "px",
        y: (box.y - 39 + document.scrollingElement.scrollTop) + "px"
      };
      x$ = this.elem.style;
      x$.left = coord.x;
      x$.top = coord.y;
      x$.display = 'block';
      this.elem.classList.add('ld', animation);
      import$(this.coord, coord);
      return this.elem.querySelector('input').value = text;
    }
  };
  textHandle.init();
  nodeHandle = {
    elem: null,
    init: function(){
      var this$ = this;
      this.elem = document.querySelector('#editor-node-handle');
      return this.elem.addEventListener('click', function(e){
        var target, parent, className, newnode, x$;
        if (!this$.target) {
          return;
        }
        target = this$.target;
        parent = target.parentNode;
        className = e.target.getAttribute('class');
        if (/fa-clone/.exec(className)) {
          newnode = target.cloneNode(true);
          newnode.setAttribute('edit-transition', 'jump-in');
          aux.cleanAttrs(newnode, ['eid']);
          sortEditable.initChild(newnode);
          if (newnode.getAttribute('image') || newnode.getAttribute('resizable')) {
            imageHandle.resizable(newnode);
          }
          parent.insertBefore(newnode, target.nextSibling);
          setTimeout(function(){
            newnode.setAttribute('edit-transition', 'jump-in');
            return editProxy.editBlock(parent);
          }, 800);
        } else if (/fa-trash-o/.exec(className)) {
          target.setAttribute('edit-transition', 'jump-out');
          setTimeout(function(){
            parent.removeChild(target);
            editProxy.editBlock(parent);
            return this$.toggle(null);
          }, 400);
        } else if (/fa-align/.exec(className)) {
          x$ = target.style;
          x$.marginLeft = /right|center/.exec(className) ? 'auto' : 0;
          x$.marginRight = /left|center/.exec(className) ? 'auto' : 0;
          x$.display = 'block';
          editProxy.editBlock(target);
        } else if (/fa-link/.exec(className)) {} else if (/fa-camera/.exec(className)) {
          imageHandle.click(this$.target);
        } else if (/fa-lock/.exec(className)) {
          imageHandle.aspect.toggle(true, target);
          this$.elem.classList.add('aspect-ratio-on');
        } else if (/fa-unlock-alt/.exec(className)) {
          imageHandle.aspect.toggle(false, target);
          this$.elem.classList.remove('aspect-ratio-on');
        }
        this$.elem.style.display = "none";
        return editProxy.editBlock(parent);
      });
    },
    coord: {
      x: 0,
      y: 0
    },
    toggle: function(options){
      var animation, node, ref$, box, ebox, coord, x$;
      options == null && (options = {});
      if (!this.elem) {
        this.init();
      }
      animation = 'ldt-float-up-in';
      node = options.node;
      if (node !== this.target) {
        this.elem.classList.remove(animation, 'xhalf');
      }
      if (!node) {
        return this.elem.style.display = 'none';
      }
      this.elem.classList[options.noRepeat ? 'add' : 'remove']('no-repeat');
      this.elem.classList[options.image ? 'add' : 'remove']('image');
      this.elem.classList[options.noDelete && options.noRepeat ? 'add' : 'remove']('no-delete');
      this.elem.classList[options.aspectRatio ? 'add' : 'remove']('aspect-ratio');
      this.elem.classList[options.alignment ? 'add' : 'remove']('alignment');
      ref$ = [node, node.getBoundingClientRect(), this.elem.getBoundingClientRect()], this.target = ref$[0], box = ref$[1], ebox = ref$[2];
      if (options.aspectRatio) {
        if (this.target.getAttribute('preserve-aspect-ratio')) {
          this.elem.classList.add('aspect-ratio-on');
        }
      }
      coord = {
        x: (box.x + box.width + 3 + (options.inside ? -5 : 0)) + "px",
        y: (box.y + box.height * 0.5 - ebox.height * 0.5 + document.scrollingElement.scrollTop) + "px"
      };
      x$ = this.elem.style;
      x$.left = coord.x;
      x$.top = coord.y;
      x$.display = 'block';
      this.elem.classList.add('ld', animation, 'xhalf');
      return import$(this.coord, coord);
    }
  };
  nodeHandle.init();
  sortEditable = {
    initChild: function(node){
      return Array.from(node.querySelectorAll('[repeat-host]')).map(function(host){
        var repeatSelector, that;
        repeatSelector = (that = host.getAttribute('repeat-class'))
          ? '.' + that
          : host.childNodes.length ? (that = host.childNodes[0] && (host.childNodes[0].getAttribute('class') || '').split(' ')[0].trim())
            ? '.' + that
            : host.nodeName : 'div';
        return Sortable.create(host, {
          group: {
            name: "sortable-" + Math.random().toString(16).substring(2)
          },
          disabled: false,
          draggable: repeatSelector,
          dragoverBubble: true,
          onEnd: function(evt){
            return editProxy.editBlock(node);
          }
        });
      });
    },
    init: function(node, redo){
      var lastRange, this$ = this;
      redo == null && (redo = false);
      this.initChild(node);
      lastRange = null;
      if (redo) {
        return;
      }
      node.addEventListener('selectstart', function(e){
        return e.allowSelect = true;
      });
      node.addEventListener('keypress', function(e){
        var selection, range, target;
        if (!e.target) {
          return;
        }
        selection = window.getSelection();
        if (!selection || (selection.rangeCount = 0)) {
          return;
        }
        range = selection.getRangeAt(0);
        target = range.startContainer;
        if (target.nodeType === 3) {
          target = target.parentNode;
        }
        if (!target.getAttribute('eid')) {
          aux.eid(target);
          return editProxy.editBlock(target);
        }
      });
      node.addEventListener('mousedown', function(e){
        var target, ret;
        Array.from(node.parentNode.querySelectorAll('[contenteditable]')).map(function(it){
          if (it.getAttribute('editable') === 'false') {
            return;
          }
          return it.removeAttribute('contenteditable');
        });
        target = e.target;
        ret = this$.search(target, document.createRange(), {
          x: e.clientX,
          y: e.clientY
        });
        if (!target.innerHTML.replace(/(<br>\s*)*/, '').trim() || (ret && ret.length && ret[0] && ((ret[1] < ret[0].length && ret[1] >= 0) && ret[2] < 800))) {
          if (target.getAttribute('editable') === 'true') {
            return target.setAttribute('contenteditable', true);
          } else {
            return node.setAttribute('contenteditable', true);
          }
        }
      });
      node.addEventListener('mousemove', function(e){
        var target, ret, selection, imageAttr;
        if (!e.buttons) {
          target = e.target;
          ret = this$.search(e.target, document.createRange(), {
            x: e.clientX,
            y: e.clientY
          });
          while (target && target.getAttribute) {
            if (target.getAttribute('repeat-item')) {
              break;
            }
            target = target.parentNode;
          }
          if (target && target.getAttribute) {
            selection = window.getSelection();
            if (selection.extentOffset === 0 && (!ret || !(ret[2] != null) || ret[2] > 800)) {
              e.target.setAttribute('contenteditable', false);
            } else {
              e.target.setAttribute('contenteditable', true);
            }
          }
        }
        target = e.target;
        while (target && target.getAttribute) {
          if (target.getAttribute('image') || target.getAttribute('repeat-item')) {
            break;
          }
          target = target.parentNode;
        }
        if (!target || !target.getAttribute) {
          return;
        }
        imageAttr = target.getAttribute('image');
        return nodeHandle.toggle({
          node: target,
          inside: true,
          noRepeat: !target.getAttribute('repeat-item'),
          image: !!imageAttr,
          noDelete: target.getAttribute('editable') === 'false',
          aspectRatio: !!(imageAttr && imageAttr !== 'bk'),
          alignment: !!(imageAttr && imageAttr !== 'bk' && !target.getAttribute('repeat-item'))
        });
      });
      node.addEventListener('mouseover', function(e){
        var target, text, placeholder;
        target = e.target;
        while (target && target.getAttribute) {
          if (target.getAttribute('edit-text')) {
            break;
          }
          target = target.parentNode;
        }
        if (!target || !target.getAttribute) {
          return textHandle.toggle({
            delay: 500
          });
        }
        text = target.getAttribute(target.getAttribute('edit-text'));
        placeholder = target.getAttribute('edit-text-placeholder') || 'enter some text...';
        return textHandle.toggle({
          node: target,
          inside: true,
          text: text,
          placeholder: placeholder
        });
      });
      return node.addEventListener('click', function(e){
        var afterResize, cursor, cancelEditable, selection, range, target, editable, ret, that, calcRange, order;
        if (e.target && e.target._interactResize) {
          afterResize = true;
          delete e.target._interactResize;
        } else {
          afterResize = false;
        }
        cursor = null;
        cancelEditable = false;
        selection = window.getSelection();
        if (selection.rangeCount > 0) {
          range = window.getSelection().getRangeAt(0);
          if (range.startOffset < range.endOffset || !range.collapsed) {
            return;
          }
          cursor = [range.startContainer, range.startOffset];
        }
        target = e.target;
        while (target && target.parentNode && target.getAttribute) {
          if (target.getAttribute('repeat-item')) {
            break;
          }
          target = target.parentNode;
        }
        if (target && target.getAttribute && target.getAttribute('repeat-item')) {
          nodeHandle.toggle({
            node: target
          });
        } else {
          nodeHandle.toggle(null);
        }
        if (e.target && e.target.getAttribute && e.target.getAttribute('repeat-item') && !afterResize) {
          target = e.target;
          target.setAttribute('contenteditable', true);
          target.focus();
          selection = window.getSelection();
          if (selection.rangeCount) {
            range = selection.getRangeAt(0);
          } else {
            range = document.createRange();
            selection.addRange(range);
          }
          range.collapse(false);
          range.selectNodeContents(target);
          return;
        }
        target = e.target;
        editable = target.getAttribute('editable');
        if (editable === 'false') {
          cancelEditable = true;
        }
        target.removeAttribute('contenteditable');
        while (target) {
          if (target.getAttribute('editable') === 'true') {
            break;
          }
          if ((target.getAttribute('image') && target.getAttribute('image') !== 'bk') || target.getAttribute('editable') === 'false') {
            cancelEditable = true;
            break;
          } else if (target.parentNode && target.parentNode.getAttribute('repeat-host') === 'true') {
            break;
          }
          if (!target.parentNode) {
            return;
          }
          if (target === node) {
            break;
          }
          target = target.parentNode;
        }
        target.setAttribute('contenteditable', !cancelEditable);
        if (cancelEditable) {
          return;
        }
        range = document.createRange();
        ret = (that = cursor)
          ? that
          : this$.search(target, range, {
            x: e.clientX,
            y: e.clientY
          });
        if (!ret || ret.length === 0) {
          return;
        }
        calcRange = (that = document.caretPositionFromPoint)
          ? that(e.clientX, e.clientY)
          : document.caretRangeFromPoint(e.clientX, e.clientY);
        ret[0] = calcRange.startContainer;
        ret[1] = calcRange.startOffset;
        if (lastRange && e.shiftKey && e.target.getAttribute('repeat-item')) {
          order = [[lastRange.startContainer, lastRange.startOffset], [ret[0], ret[1]]];
          if (order[0][1] > order[1][1]) {
            order = [order[1], order[0]];
          }
          range.setStart(order[0][0], order[0][1]);
          range.setEnd(order[1][0], order[1][1]);
        } else {
          range.setStart(ret[0], ret[1]);
          range.collapse(true);
        }
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        return lastRange = range;
      });
    },
    search: function(node, range, m, root){
      var ret, i$, to$, i, child, ref$, idx, dx, dy, j$, to1$, j, box, size, min;
      root == null && (root = true);
      ret = [];
      for (i$ = 0, to$ = node.childNodes.length; i$ < to$; ++i$) {
        i = i$;
        child = node.childNodes[i];
        if (child.nodeName === '#text') {
          ref$ = [-1, -1, -1], idx = ref$[0], dx = ref$[1], dy = ref$[2];
          for (j$ = 0, to1$ = child.length + 1; j$ < to1$; ++j$) {
            j = j$;
            range.setStart(child, j);
            box = range.getBoundingClientRect();
            size = box.height;
            if (box.x <= m.x && box.y <= m.y) {
              idx = j;
              dx = (m.x - box.x - size * 0.5) / size * 16;
              dy = (m.y - box.y - size * 0.5) / size * 16;
            } else if (box.x > m.x && box.y > m.y) {
              break;
            }
          }
          if (idx >= 0) {
            ret.push([child, idx, dx, dy]);
          }
          continue;
        }
        if (!child.getBoundingClientRect) {
          continue;
        }
        box = child.getBoundingClientRect();
        if (box.x <= m.x && box.y <= m.y) {
          ret = ret.concat(this.search(child, range, m, false));
        }
      }
      if (!root || !ret.length) {
        return ret;
      }
      ret = ret.map(function(it){
        return [it[0], it[1], Math.pow(it[2], 2) + Math.pow(it[3], 2)];
      });
      ref$ = [ret[0][2], 0], min = ref$[0], idx = ref$[1];
      for (i$ = 1, to$ = ret.length; i$ < to$; ++i$) {
        i = i$;
        if (ret[i][2] < min) {
          ref$ = [ret[i][2], i], min = ref$[0], idx = ref$[1];
        }
      }
      return ret[idx];
    }
  };
  page = {
    share: {
      modal: {},
      link: window.location.origin + (window.location.pathname + "/view").replace(/\/\//g, '/'),
      'public': false,
      setPublic: function(it){
        if (this['public'] === it) {
          return;
        }
        this['public'] = it;
        return collaborate.action.setPublic(this['public']);
      }
    },
    prepare: function(data){
      var x$;
      x$ = document.querySelector('#editor > .inner');
      x$.setAttribute('style', data.style || '');
      x$.style.width = $scope.config.size.value + "px";
      return this.share.setPublic((data.attr || {}).isPublic);
    }
  };
  block = {
    defaultInterface: {
      init: function(){},
      update: function(){},
      change: function(){},
      destroy: function(){}
    },
    library: {
      root: null,
      loaded: {},
      scripts: {},
      add: function(name){
        var this$ = this;
        return Promise.resolve().then(function(){
          if (this$.loaded[name]) {
            return;
          }
          return blockLoader.get(name);
        }).then(function(ret){
          var libraries, node, k, v, script;
          ret == null && (ret = {});
          if (!this$.root) {
            this$.root = document.querySelector('#editor-library');
          }
          libraries = (ret.exports || (ret.exports = {})).library;
          if (!libraries) {
            return;
          }
          node = document.createElement("div");
          for (k in libraries) {
            v = libraries[k];
            if (this$.scripts[v]) {
              continue;
            }
            script = this$.scripts[v] = document.createElement("script");
            script.setAttribute('type', 'text/javascript');
            script.setAttribute('src', v);
            this$.root.appendChild(script);
          }
          return this$.loaded[name] = true;
        });
      }
    },
    style: {
      root: null,
      nodes: {},
      add: function(name){
        var this$ = this;
        return Promise.resolve().then(function(){
          if (this$.nodes[name]) {
            return;
          }
          return blockLoader.get(name);
        }).then(function(ret){
          var node;
          node = document.createElement("style");
          node.setAttribute('type', 'text/css');
          node.innerHTML = ret.css;
          if (!this$.root) {
            this$.root = document.querySelector('#editor-style');
          }
          return this$.root.appendChild(node);
        });
      },
      remove: function(name){
        if (!this.root || !this.nodes[name]) {
          return;
        }
        return this.root.removeChild(this.nodes[name]);
      },
      update: function(node, style){
        node.style = style;
        return editProxy.change([node]);
      }
    },
    remove: function(node){
      editProxy.deleteBlock(node);
      node.parentNode.removeChild(node);
      return editor.handles.hide(node);
    },
    init: function(){
      var e;
      editProxy.change();
      try {
        $scope.fontchooser.init();
        if ((typeof _jf != 'undefined' && _jf !== null) && _jf.flush) {
          return _jf.flush();
        }
      } catch (e$) {
        e = e$;
        return console.log(e);
      }
    },
    clone: function(node){
      var code;
      if (!node.childNodes[0]) {
        return;
      }
      code = node.childNodes[0].innerHTML;
      return this.prepare(code, {
        highlight: true,
        idx: Array.from(node.parentNode.childNodes).indexOf(node) + 1,
        name: node.getAttribute('base-block'),
        source: true,
        style: node.getAttribute('style')
      });
    },
    prepareHandle: {},
    prepareAsync: function(node, options){
      var this$ = this;
      options == null && (options = {
        idx: 0
      });
      return new Promise(function(res, rej){
        var idx;
        idx = options.idx || 0;
        if (this$.prepareHandle[idx]) {
          $timeout.cancel(this$.prepareHandle[idx]);
        }
        return this$.prepareHandle[idx] = $timeout(function(){
          this$.prepareHandle[idx] = 0;
          return this$.prepare(node, options).then(function(it){
            return res(it);
          })['catch'](function(it){
            return rej(it);
          });
        }, 10);
      });
    },
    indexing: function(){
      return btools.qsAll('#editor > .inner > [base-block]').map(function(d, i){
        return d.idx = i;
      });
    },
    prepare: function(node, options){
      var name, idx, redo, style, source, code, root, inner, that, eid, i$, i, promise, this$ = this;
      options == null && (options = {
        source: true
      });
      editor.cursor.save();
      name = options.name, idx = options.idx, redo = options.redo, style = options.style, source = options.source;
      code = null;
      if (typeof node === 'string') {
        code = node;
        node = document.createElement("div");
        root = document.querySelector('#editor > .inner');
        root.insertBefore(node, root.childNodes[idx]);
        editor.placeholder.remove();
      }
      if (options.content) {
        inner = Array.from(node.childNodes).filter(function(it){
          return /inner/.exec(it.getAttribute('class'));
        })[0];
        if (inner) {
          inner.innerHTML = puredom.sanitize(options.content);
        }
      }
      name = name || node.getAttribute('base-block');
      Array.from(node.attributes).map(function(it){
        var ref$;
        if (!((ref$ = it.name) === 'base-block' || ref$ === 'style')) {
          return node.removeAttribute(it.name);
        }
      });
      node.setAttribute('class', "initializing");
      if (that = options.eid) {
        eid = that;
      } else if (that = node.getAttribute('eid')) {
        eid = that;
      } else {
        for (i$ = 0; i$ < 100; ++i$) {
          i = i$;
          eid = Math.random().toString(16).substring(2);
          if (!document.querySelector("[eid='" + eid + "']")) {
            break;
          }
        }
      }
      node.setAttribute('eid', eid);
      node.setAttribute('id', "block-id-" + eid);
      return promise = blockLoader.get(name).then(function(ret){
        var inner, handle, ref$, me;
        node.setAttribute('class', "block-item block-" + name);
        node.setAttribute('base-block', name);
        if (!redo) {
          inner = document.createElement("div");
          inner.setAttribute('class', 'inner');
          inner.innerHTML = code
            ? puredom.sanitize(code)
            : ret.html;
          if (code && source) {
            aux.cleanAttrs(inner, ['eid']);
          }
          if (style) {
            node.setAttribute("style", style);
          }
          while (node.lastChild) {
            node.removeChild(node.lastChild);
          }
          node.appendChild(inner);
          handle = document.createElement("div");
          handle.setAttribute('class', 'handle ld ldt-float-left-in');
          handle.innerHTML = ['arrows', 'clone', 'cog', 'trash-o'].map(function(it){
            return "<i class='fa fa-" + it + "'></i>";
          }).join('');
          handle.addEventListener('click', function(e){
            var classList;
            classList = e.target.classList;
            if (classList.contains('fa-trash-o')) {
              return this$.remove(node);
            } else if (classList.contains('fa-clone')) {
              return this$.clone(node);
            } else if (classList.contains('fa-cog')) {
              return $scope.blockConfig.toggle(node);
            }
          });
          node.appendChild(handle);
          node.addEventListener('dragstart', function(e){
            return medium.pause();
          });
          node.addEventListener('dragend', function(e){
            return medium.resume();
          });
          node.addEventListener('drop', function(e){
            return medium.resume();
          });
          block.style.add(name);
          block.library.add(name);
        }
        if (!node.obj) {
          node.obj = new Object();
          node.obj.__proto__ = import$(import$(import$({}, node.obj.__proto__), block.defaultInterface), ret.exports || (ret.exports = {}));
          ref$ = node.obj;
          ref$.collab = collaborate;
          ref$.block = node;
          ref$.page = pageObject;
          ref$.viewMode = false;
          node.obj.init();
        }
        if (!redo && source) {
          editProxy.insertBlock(node);
        }
        if (!redo && options.highlight) {
          node.classList.add('ld', 'ldt-jump-in', 'fast');
        }
        inner = node.querySelector('.block-item > .inner');
        imageHandle.resizable(Array.from(inner.querySelectorAll('*[image]')));
        imageHandle.resizable(Array.from(inner.querySelectorAll('*[resizable]')));
        if (node.obj.editable !== false) {
          me = medium.prepare(inner);
        }
        sortEditable.init(inner, redo);
        node.obj.change(null, options.source);
        editor.cursor.load();
        return node;
      });
    }
  };
  $scope.css = {
    init: function(){
      var this$ = this;
      this.node = document.querySelector('#editor-css');
      this.style = document.querySelector('#editor-css style');
      $scope.$watch('css.inline.value', function(n, o){
        if (n === o) {
          return;
        }
        collaborate.action.css.editInline(n);
        return this$.style.textContent = n;
      });
      $scope.$watch('css.theme.value.name', function(n, o){
        if (n !== o) {
          return collaborate.action.css.editTheme($scope.css.theme.value);
        }
      });
      return this.theme.value = this.theme.list[0];
    },
    prepare: function(css){
      var this$ = this;
      css == null && (css = {});
      return $scope.force$apply(function(){
        var ref$;
        this$.inline.value = css.inline;
        this$.theme.value = css.theme;
        return (ref$ = this$.links).list = ref$.list.concat(css.links);
      });
    },
    theme: {
      value: {},
      list: {
        name: "Default"
      },
      update: function(value){
        var this$ = this;
        return $scope.force$apply(function(){
          return this$.value = value;
        });
      }
    },
    inline: {
      value: "",
      update: function(value){
        var this$ = this;
        return $scope.force$apply(function(){
          return this$.value = value;
        });
      }
    },
    links: {
      value: null,
      list: [],
      add: function(value, local){
        var this$ = this;
        local == null && (local = false);
        return $scope.force$apply(function(){
          if (!value) {
            return;
          }
          this$.list.push(value);
          if (!local) {
            return;
          }
          collaborate.action.css.addLink(value);
          return this$.value = null;
        });
      },
      remove: function(value, local){
        var this$ = this;
        local == null && (local = false);
        return $scope.force$apply(function(){
          var idx;
          if (!value) {
            return;
          }
          idx = this$.list.indexOf(value);
          if (!~idx) {
            return;
          }
          this$.list.splice(idx, 1);
          if (!local) {
            return;
          }
          collaborate.action.css.removeLink(value);
          return this$.value = null;
        });
      }
    }
  };
  $scope.css.init();
  editor = {
    user: $scope.user,
    css: $scope.css,
    handles: {
      hide: function(node){
        nodeHandle.toggle(null);
        return textHandle.toggle(null);
      }
    },
    reload: function(){
      return window.location.reload();
    },
    online: {
      defaultCountdown: 10,
      state: true,
      code: null,
      retry: function(){
        editor.loading.toggle(true);
        this.state = true;
        $timeout(function(){
          return collaborate.init(document.querySelector('#editor .inner'), editor);
        }, 100);
        if (!this.retry.countdown || this.retry.countdown < 0) {
          return this.retry.countdown = this.defaultCountdown;
        } else {
          return this.retry.countdown--;
        }
      },
      toggle: function(v, options){
        var this$ = this;
        options == null && (options = {});
        return $scope.force$apply(function(){
          if (!options && this$.retry.countdown) {
            return this$.retry();
          }
          this$.code = options.code;
          editor.online.state = v;
          return editor.loading.toggle(true);
        });
      }
    },
    loading: {
      toggle: function(v){
        return $scope.force$apply(function(){
          if (v != null) {
            return $scope.loading = v;
          } else {
            return $scope.loading = !$scope.loading;
          }
        });
      }
    },
    server: (ref$ = {}, ref$.domain = global.domain, ref$.scheme = global.scheme, ref$),
    collaborator: {
      list: {},
      count: 0,
      init: function(){
        var this$ = this;
        return $timeout(function(){
          var k, ref$, v, results$ = [];
          this$.count = 0;
          for (k in ref$ = this$.list || {}) {
            v = ref$[k];
            this$.list[k].cbox = editor.cursor.toBox(this$.list[k].cursor || {});
            results$.push(this$.count++);
          }
          return results$;
        }, 0);
      },
      handle: function(cursor){
        var ref$, that, key$, ref1$;
        if (cursor.action === 'init') {
          this.list = cursor.data;
          return this.init();
        } else if ((ref$ = cursor.action) === 'join' || ref$ === 'update') {
          if (!this.list[cursor.key]) {
            this.count++;
          }
          this.list[cursor.key] = import$(this.list[cursor.key] || {}, cursor.data);
          if (that = this.list[cursor.key].cursor) {
            return this.list[cursor.key].cbox = editor.cursor.toBox(that);
          }
        } else if (cursor.action === 'exit') {
          if (this.list[cursor.key]) {
            this.count--;
            return ref1$ = (ref$ = this.list)[key$ = cursor.key], delete ref$[key$], ref1$;
          }
        }
      }
    },
    cursor: {
      state: null,
      get: function(){
        var selection, range;
        selection = window.getSelection();
        if (!selection.rangeCount) {
          return null;
        }
        range = selection.getRangeAt(0);
        return {
          startSelector: btools.getEidSelector(range.startContainer),
          startOffset: range.startOffset,
          endSelector: btools.getEidSelector(range.endContainer),
          endOffset: range.endOffset
        };
      },
      save: function(){
        return this.state = this.get();
      },
      toBox: function(state){
        var range, rbox, box, ref$;
        range = this.toRange(state);
        rbox = document.querySelector('#editor > .inner').getBoundingClientRect();
        if (!(range && rbox)) {
          return;
        }
        box = range.getBoundingClientRect();
        ref$ = [box.x - rbox.x, box.y - rbox.y], box.x = ref$[0], box.y = ref$[1];
        return ref$ = {
          blur: box.x < 0 || box.x > rbox.width
        }, ref$.x = box.x, ref$.y = box.y, ref$.width = box.width, ref$.height = box.height, ref$;
      },
      toRange: function(state){
        var range, startContainer, endContainer, e;
        range = document.createRange();
        startContainer = btools.fromEidSelector(state.startSelector);
        endContainer = btools.fromEidSelector(state.endSelector);
        if (!startContainer) {
          return null;
        }
        try {
          range.setStart(startContainer, state.startOffset);
          if (endContainer) {
            range.setEnd(endContainer, state.endOffset);
          }
        } catch (e$) {
          e = e$;
          return null;
        }
        return range;
      },
      load: function(){
        var selection, range;
        if (!this.state) {
          return;
        }
        selection = window.getSelection();
        range = this.toRange(this.state);
        if (!range) {
          return;
        }
        selection.removeAllRanges();
        selection.addRange(range);
        return this.state = null;
      }
    },
    page: page,
    block: block,
    placeholder: {
      remove: function(){
        var node;
        node = document.querySelector('#editor > .inner > .placeholder');
        if (node) {
          return node.parentNode.removeChild(node);
        }
      }
    },
    prune: function(root){
      Array.from(root.querySelectorAll('[editable]')).map(function(n){
        return n.removeAttribute('editable');
      });
      Array.from(root.querySelectorAll('[contenteditable]')).map(function(n){
        return n.removeAttribute('contenteditable');
      });
      return Array.from(root.querySelectorAll('.block-item > .handle')).map(function(n){
        return n.parentNode.removeChild(n);
      });
    },
    'export': function(option){
      var root, style, css, baseStyle, payload;
      option == null && (option = {});
      root = document.querySelector('#editor > .inner').cloneNode(true);
      style = document.querySelector('#editor-style');
      css = document.querySelector('#editor-css');
      baseStyle = document.querySelector('#page-basic');
      this.prune(root);
      if (option.bodyOnly) {
        payload = root.innerHTML;
      } else {
        payload = "<html><head>\n<link rel=\"stylesheet\" type=\"text/css\"\nhref=\"https://makeweb.io/blocks/all.min.css\"/>\n<link rel=\"stylesheet\" type=\"text/css\"\nhref=\"https://makeweb.io/css/pack/viewer.min.css\"/>\n<script type=\"text/javascript\"\nsrc=\"https://makeweb.io/js/pack/viewer.js\"></script>\n" + style.innerHTML + "\n<style type=\"text/css\"> " + baseStyle.innerHTML + " </style>\n" + css.innerHTML + "\n</head><body>\n" + root.innerHTML + "\n</body></html>";
      }
      return puredom.sanitize(payload, {
        ADD_TAGS: ['html', 'head', 'body', 'link', 'style'],
        WHOLE_DOCUMENT: true
      });
    }
  };
  Sortable.create(document.querySelector('#blocks-picker'), {
    group: {
      name: 'block',
      put: false,
      pull: 'clone'
    },
    disabled: false,
    sort: false,
    draggable: '.block-thumb'
  });
  Sortable.create(document.querySelector('#editor .inner'), {
    group: {
      name: 'block',
      pull: 'clone'
    },
    filter: '.unsortable',
    preventOnFilter: false,
    disabled: false,
    draggable: '.block-item',
    dragoverBubble: true,
    scrollSensitivity: 60,
    scrollSpeed: 30,
    onAdd: function(it){
      return block.prepare(it.item);
    },
    onStart: function(evt){
      var lists;
      lists = btools.qsAll('iframe', evt.item);
      evt.item._iframes = lists;
      return lists.map(function(it){
        it._original = {
          parentNode: it.parentNode,
          nextSibling: it.nextSibling
        };
        return it.parentNode.removeChild(it);
      });
    },
    onEnd: function(evt){
      var ref$, src, des;
      ref$ = [evt.oldIndex, evt.newIndex], src = ref$[0], des = ref$[1];
      if (evt.item._iframes) {
        evt.item._iframes.map(function(it){
          return it._original.parentNode.insertBefore(it, it._original.nextSibling);
        });
      }
      if (evt.clone.deleted) {
        this.el.removeChild(evt.item);
        return ldNotify.warning('The block you drag is deleted by others.');
      } else {
        if (evt.clone.idx != null && evt.clone.idx !== evt.oldIndex) {
          src = evt.clone.idx;
        }
        if (src === des) {
          return;
        }
        return editProxy.moveBlock(src, des);
      }
    }
  });
  x$ = document.querySelector('#editor > .inner');
  x$.addEventListener('dragover', function(){
    return editor.placeholder.remove();
  });
  $scope.collaborator = editor.collaborator;
  $scope['export'] = {
    modal: {
      config: {},
      ctrl: {}
    },
    run: function(){
      this.code = editor['export']();
      return this.modal.ctrl.toggle(true);
    }
  };
  $scope.preview = {
    modal: {},
    run: function(){
      document.querySelector('#editor-preview iframe').setAttribute('src', page.share.link + "?preview=true");
      return this.modal.ctrl.toggle(true);
    }
  };
  $scope.config = {
    modal: {},
    size: {
      value: 1024,
      name: '1024px',
      resizeAsync: ldBase.async('resize', function(){
        var this$ = this;
        return $scope.force$apply(function(){
          var maxSize, i$, ref$, len$, size;
          maxSize = window.innerWidth - 180 * 2;
          for (i$ = 0, len$ = (ref$ = [1440, 1200, 1024, 800, 640, 480]).length; i$ < len$; ++i$) {
            size = ref$[i$];
            if (size < maxSize) {
              break;
            }
          }
          return this$.set(size + "px");
        });
      }),
      relayout: function(){
        var widgets, panel, preview, inner;
        widgets = document.querySelector('#blocks-picker');
        panel = document.querySelector('#collab-info');
        preview = document.querySelector('.editor-preview-modal .cover-modal-inner');
        inner = document.querySelector('#editor > .inner');
        widgets.style.right = (this.value + Math.round((window.innerWidth - this.value) / 2)) + "px";
        panel.style.left = (this.value + Math.round((window.innerWidth - this.value) / 2)) + "px";
        preview.style.width = this.value + "px";
        inner.style.width = this.value + "px";
        return setTimeout(function(){
          return Array.from(document.querySelectorAll('#editor > .inner *[base-block]')).map(function(block){
            if ((block.obj || (block.obj = {})).resize) {
              return (block.obj || (block.obj = {})).resize();
            }
          });
        }, 1000);
      },
      set: function(name){
        if (/px/.exec(name)) {
          this.value = parseInt(name.replace(/px/, ''));
        } else if (/Full/.exec(name)) {
          this.value = window.innerWidth;
        } else if (/%/.exec(name)) {
          this.value = window.innerWidth * Math.round(name.replace(/%/, '')) * 0.01;
        }
        this.name = name;
        return this.relayout();
      }
    }
  };
  $scope.insert = {
    node: function(node){
      return new Promise(function(res, rej){
        var selection, range, target;
        editor.cursor.load();
        selection = window.getSelection();
        if (!(selection && selection.rangeCount)) {
          return rej();
        }
        range = selection.getRangeAt(0);
        target = range.startContainer;
        while (target && (target.getAttribute || target.nodeType === 3)) {
          if (target.getAttribute && target.getAttribute('base-block')) {
            break;
          }
          target = target.parentNode;
        }
        if (target.nodeType !== 3 && !(target && target.getAttribute && target.getAttribute('base-block'))) {
          return;
        }
        range.collapse(true);
        range.insertNode(node);
        range.setStartAfter(node);
        selection.removeAllRanges();
        selection.addRange(range);
        return res();
      });
    },
    image: function(){
      var shrink, dialog, this$ = this;
      shrink = "1024x1024";
      dialog = uploadcare.openDialog(null, null, {
        imageShrink: shrink,
        crop: 'free'
      });
      return dialog.done(function(it){
        var file, that, img, imgInner;
        file = ((that = it.files)
          ? that()
          : [it])[0];
        img = document.createElement("div");
        img.setAttribute('editable', false);
        img.setAttribute('contenteditable', false);
        img.setAttribute('image', 'image');
        img.setAttribute('preserve-aspect-ratio', true);
        imgInner = document.createElement("div");
        imgInner.style.paddingBottom = "50%";
        img.appendChild(imgInner);
        img.style.width = "3em";
        img.style.height = "auto";
        img.style.backgroundImage = "url(/assets/img/loader/msg.svg)";
        img.style.backgroundColor = '#ccc';
        return this$.node(img).then(function(){
          return file.done(function(info){
            var ratio;
            ratio = Math.round(100 * (info.crop.width / info.crop.height)) * 0.01;
            img.setAttribute('image-ratio', ratio);
            img.style.backgroundImage = "url(" + info.cdnUrl + ")";
            img.style.backgroundColor = "";
            img.style.width = info.crop.width + "px";
            img.style.backgroundSize = "100% 100%";
            imgInner.style.paddingBottom = 100 / ratio + "%";
            imageHandle.resizable(img);
            return editProxy.editBlock(img);
          });
        })['catch'](function(){});
      });
    },
    hr: function(){
      var hr;
      hr = document.createElement("hr");
      return this.node(hr).then(function(){
        return editProxy.editBlock(hr);
      });
    },
    button: function(){
      var btnContainer, btn;
      btnContainer = document.createElement("a");
      btnContainer.setAttribute('repeat-host', 'repeat-host');
      btn = document.createElement("a");
      btn.classList.add('btn', 'btn-primary', 'm-1');
      btn.innerHTML = "Get Start";
      btn.setAttribute('href', "#");
      btn.setAttribute('editable', "true");
      btn.setAttribute('repeat-item', "repeat-item");
      btnContainer.appendChild(btn);
      return this.node(btnContainer).then(function(){
        return editProxy.editBlock(btnContainer);
      });
    },
    icon: function(){
      return $scope.iconPicker.toggle();
    },
    toggle: function(value, box){
      var handle, scrolltop, x$, y$, top;
      box == null && (box = {});
      handle = document.querySelector('#editor-insert-handle');
      handle.style.display = value ? 'block' : 'none';
      if (value) {
        scrolltop = document.scrollingElement.scrollTop;
        x$ = handle.style;
        x$.top = '10px';
        x$.opacity = 0.8;
        return x$;
      } else {
        y$ = handle.style;
        top = '-100px';
        y$.opacity = 0;
        return y$;
      }
    }
  };
  ['keyup', 'mouseup', 'focus', 'blur'].map(function(it){
    return document.body.addEventListener(it, function(e){
      return setTimeout(function(){
        var sel, block;
        sel = window.getSelection();
        if (!sel.isCollapsed || !sel.rangeCount) {
          return $scope.insert.toggle(false);
        }
        block = btools.traceUp("[contenteditable='true']", e.target);
        if (!block) {
          return $scope.insert.toggle(false);
        }
        return $scope.insert.toggle(true, sel.getRangeAt(0).getBoundingClientRect());
      }, 0);
    });
  });
  $scope.iconPicker = {
    modal: {},
    toggle: function(){
      return this.modal.ctrl.toggle();
    },
    keyword: '',
    click: function(e){
      var code, icon;
      if (!e.target || !e.target.getAttribute) {
        return;
      }
      code = e.target.getAttribute("c");
      if (!code) {
        return;
      }
      code = "&#x" + code + ";";
      icon = document.createElement("i");
      icon.classList.add('fa-icon');
      icon.innerHTML = code;
      $scope.insert.node(icon);
      this.modal.ctrl.toggle(false);
      return editProxy.editBlock(icon);
    },
    init: function(){
      var this$ = this;
      return $scope.$watch('iconPicker.keyword', function(){
        return btools.qsAll('#editor-icon-picker-list i.fa').map(function(it){
          if (!this$.keyword || this$.keyword === '' || ~it.classList.value.indexOf(this$.keyword)) {
            return it.classList.remove('d-none');
          } else {
            return it.classList.add('d-none');
          }
        });
      });
    }
  };
  $scope.iconPicker.init();
  $scope.pageConfig = {
    modal: {},
    tab: 1,
    toggle: function(){
      webSettings.setBlock(document.querySelector('#editor > .inner'));
      return this.modal.ctrl.toggle();
    }
  };
  $scope.blockConfig = {
    modal: {},
    toggle: function(node){
      webSettings.setBlock(node);
      return this.modal.ctrl.toggle();
    }
  };
  $scope.share = page.share;
  $scope.$watch('config.size.value', function(){
    return $scope.config.size.relayout();
  });
  $scope.$watch('user.data.key', function(n, o){
    if ((n || o) && n !== o) {
      return $timeout(function(){
        return window.location.reload();
      }, 5000);
    }
  });
  $scope.editor = editor;
  document.body.addEventListener('keyup', function(e){
    nodeHandle.toggle(null);
    return editProxy.editBlock(e.target);
  });
  editor.online.retry();
  document.querySelector('#editor .inner').addEventListener('click', function(e){
    var target;
    target = e.target;
    while (target) {
      if (target.getAttribute && target.getAttribute('edit-text')) {
        break;
      }
      target = target.parentNode;
    }
    if (target && target.getAttribute && target.getAttribute('edit-text')) {
      return textHandle.toggle(null);
    }
  });
  lastCursor = null;
  $interval(function(){
    var cursor;
    if (!$scope.user.data) {
      return;
    }
    cursor = editor.cursor.get();
    if (JSON.stringify(cursor) === JSON.stringify(lastCursor)) {
      return;
    }
    collaborate.action.cursor($scope.user.data, cursor);
    return lastCursor = cursor;
  }, 1000);
  document.body.addEventListener('mouseup', function(){
    var selection, range, ref$, start, end, cur, oldend;
    selection = window.getSelection();
    if (!selection.rangeCount) {
      return;
    }
    range = selection.getRangeAt(0);
    ref$ = [range.startContainer, range.endContainer], start = ref$[0], end = ref$[1];
    if (start !== end) {
      cur = start;
      while (cur && cur.parentNode) {
        cur = cur.parentNode;
        if (end === cur) {
          return range.selectNodeContents(start);
        }
      }
      oldend = end;
      while (end && end.parentNode) {
        end = end.previousSibling || end.parentNode;
        if (end.childNodes.length === 0 || (end === oldend.parentNode && Array.from(end.childNodes).indexOf(oldend) === 0)) {
          continue;
        }
        break;
      }
    }
    if (start.nodeType === 3) {
      start = start.previousSibling || start.parentNode;
    }
    if (end.nodeType === 3) {
      end = end.previousSibling || end.parentNode;
    }
    if (start === end && end !== range.endContainer && range.endOffset === 0) {
      return range.selectNodeContents(start);
    }
  });
  blocksPicker = document.querySelector('#blocks-picker');
  blocksPreview = document.querySelector('#blocks-preview');
  blocksPicker.addEventListener('dragstart', function(){
    return blocksPreview.style.display = 'none';
  });
  blocksPicker.addEventListener('mouseout', function(e){
    return blocksPreview.style.display = 'none';
  });
  blocksPicker.addEventListener('mousemove', function(e){
    var target, box, name, ratio, windowBottom, popupTop, popupHeight, x$, y$;
    target = e.target;
    if (!target.classList || !target.classList.contains("thumb")) {
      if (target !== blocksPicker) {
        blocksPreview.style.display = 'none';
      }
      return;
    }
    box = target.getBoundingClientRect();
    name = target.getAttribute('name');
    ratio = target.getAttribute('ratio');
    if (ratio < 20) {
      ratio = 20;
    }
    windowBottom = window.innerHeight + document.scrollingElement.scrollTop;
    popupTop = box.y + box.height * 0.5 - 25 + document.scrollingElement.scrollTop;
    popupHeight = 2.56 * ratio;
    if (popupTop + popupHeight > windowBottom - 5) {
      popupTop = windowBottom - popupHeight - 5;
    }
    x$ = blocksPreview.style;
    x$.left = (box.x + box.width) + "px";
    x$.top = popupTop + "px";
    x$.display = 'block';
    blocksPreview.querySelector('.name').innerText = name;
    y$ = blocksPreview.querySelector('.inner').style;
    y$.backgroundImage = "url(/blocks/" + name + "/index.png)";
    y$.height = "0";
    y$.paddingBottom = (ratio - 1) + "%";
    return y$;
  });
  document.addEventListener('scroll', function(){
    nodeHandle.toggle(null);
    $scope.insert.toggle(false);
    return blocksPreview.style.display = 'none';
  });
  ['mousemove', 'keydown', 'scroll'].map(function(name){
    return document.addEventListener(name, function(){
      return editor.online.retry.countdown = editor.online.defaultCountdown;
    });
  });
  window.addEventListener('resize', function(){
    return $scope.config.size.resizeAsync();
  });
  $scope.config.size.resizeAsync();
  window.addEventListener('keydown', function(e){
    if (!(e.metaKey || e.ctrlKey)) {
      return;
    }
    if (e.keyCode === 90) {
      collaborate.history.undo();
      e.preventDefault();
      return false;
    }
  });
  document.addEventListener('selectionchange', function(e){
    var sel, range, ref$, end, offset;
    sel = window.getSelection();
    if (!sel.rangeCount) {
      return;
    }
    range = sel.getRangeAt(0);
    ref$ = [range.endContainer, range.endOffset], end = ref$[0], offset = ref$[1];
    if (end.getAttribute && end.getAttribute('editable') === 'false') {
      while (end && !end.previousSibling) {
        end = end.parentNode;
      }
      if (!end || !end.previousSibling) {
        return;
      }
      end = end.previousSibling;
      offset = end.length || (end.childNodes && end.childNodes.length) || 0;
      range.setEnd(end, offset);
      sel.removeAllRanges();
      return sel.addRange(range);
    }
  });
  window.addEventListener('error', function(){
    return $scope.force$apply(function(){
      return $scope.crashed = true;
    });
  });
  return $scope.fontchooser = {
    enable: false,
    init: function(){
      if (!this.enable) {
        return;
      }
      return setTimeout(function(){
        var traverse, t1, hash, t2, chooser;
        traverse = function(root, hash){
          var style, i$, to$, i, results$ = [];
          if (!root || root.nodeType !== 1) {
            return;
          }
          style = window.getComputedStyle(root);
          if (style && style.fontFamily) {
            style.fontFamily.split(',').map(function(it){
              return it.trim();
            }).filter(function(it){
              return it;
            }).map(function(it){
              return hash[it] = (hash[it] || '') + root.innerText;
            });
          }
          for (i$ = 0, to$ = root.childNodes.length; i$ < to$; ++i$) {
            i = i$;
            results$.push(traverse(root.childNodes[i], hash));
          }
          return results$;
        };
        t1 = new Date().getTime();
        hash = {};
        traverse(document.querySelector('#editor > .inner'), hash);
        t2 = new Date().getTime();
        chooser = new choosefont({
          metaUrl: "/assets/choosefont.js/meta.json",
          base: "https://plotdb.github.io/xl-fontset/alpha"
        });
        chooser.on('choose', function(it){
          return it.sync(hash[it.name] || '');
        });
        return chooser.init(function(){
          var k;
          return chooser.find((function(){
            var results$ = [];
            for (k in hash) {
              results$.push(k);
            }
            return results$;
          }())).map(function(it){
            return chooser.load(it[0]);
          });
        });
      }, 1000);
    }
  };
}));
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}